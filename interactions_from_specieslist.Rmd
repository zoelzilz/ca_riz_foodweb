---
title: "interactions_from_specieslist"
output: html_document
date: "2024-03-20"
---
```{r setup and packages, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#install.packages("igraph") 
#install.packages("network") 
#install.packages("sna")
#install.packages("ggraph")
#install.packages("visNetwork")
#install.packages("threejs")
#install.packages("networkD3")
#install.packages("ndtv")
#install.packages("tidyverse")
#install.packages("NetIndices")
#install.packages("cheddar")
#install.packages("worrms")
#install.packages("taxize")
#install.packages("googlesheets4")
#install.packages("beepr")

library(igraph) 
library(network) 
library(sna)
library(ggraph)
library(visNetwork)
library(threejs)
library(networkD3)
library(ndtv) 
library(tidyverse)
library(worrms)
library(taxize)
library(janitor)
library(googlesheets4)
library(beepr)
```

# The year is 2024 and we are approaching graduation
## The time is nigh to finish the California Rocky Intertidal Food Web
## (and we are using humor to mask the despair)

### status: all nodes and links from the Light and Smith handbook have been incorporated. We are going to try to automate some of the cleaning tasks that were previously done by hand including: 
### - full taxonomy for each node 
### - creating edges by coding instead of manual entry 
### - whatever else we can code in in less time than it takes to enter manually


###CHECKLIST: bold is what's being worked on
 ✔ pull in WORMS taxonomy for each node (done except for those that don't match an entry in WORMS)
  
 ✔ manually fix typos in original node list so that they match an existing WORMS entry, if possible, using the dataset result from the above step  
  - in doing this, realized that the dataset made from rows that don't match an entry in worms is missing all morphospecies that I PO'd...?
       ✔ OH MY GOD i had filtered out all nodes with zone = south, host range, or no data. I'm an idiot. I will need to do everything above again (as of 3/5) with the new full nodes dataset (hopefully not that bad)
       ✔ Ok this has been done twice now with all nodes and is as good as it's gonna get
        
 • **go through original node list (specieslistmaster) and create a forloop to make new interactions for those listed in the interaction columns**
 
 ✔ finish code to make inferred interactions dataset from literature search data
      ✔ don't forget to include justification code and make it match existing edgelist
      ✔ include consumer_num, etc)

 ✔ QA/QC inferred interactions dataset
       
 • create code to incorporate GLOBI data into edgelist
  
 • last step: use Dana's code to make concomitant predation dataset
 
##In this markdown we will attempt to use the interaction columns in the master riz species list to add to the edge list
### first we import
```{r import master species list slash node metadata}

nodes_unclean <- read_csv("RIZspecieslist_fulltaxonomy_20mar24.csv") #using this version for now, but will likely update

```

### now we will use the metadata, mostly gathered from the two RIZ guidebooks, to plug consumer relationships into the edge list
These "data" are in columns pertaining to the type of consumer relationship, separated by commas or semi colons (not tidy, zoe, you big dingus) and often not fully resolved to species (might just need to let this one go)
```{r clean dataset for expanding consumer relationships}
consumer_nodes <- nodes_unclean %>% 
  select(!c(eaten_by, non_trophic_epicommensal_w, mutualist_w, parasitized_by, unknown_symbiosis, how_picky_symbiotically, id.y, x41, clean_zone, googled, justification, confidence, node_type, node_resolution)) %>% # removing all unneeded columns, including interactions related to consumer as the resource (we will do this later)
  
  # let's filter out the rows/species that we've already manually entered into the web:
  
  mutate(web_enter_code = replace_na(web_enter_code, 0)) %>%  # filter automatically removes NAs so we need to replace them
  filter(!web_enter_code == 1) %>% # removing code 1 (entered) and code 5 (consumer relationships entered)
  filter(!web_enter_code == 5)   # no idea why i need to do these separately, so annoying


################ now we need to expand the resources for each consumer  ##################

###### starting with prey #######
# pulling them apart by interaction type first?

#consumers_prey <- consumer_nodes %>% 
#  separate_rows(preys_on, sep = ",|;") %>%  # separate stuff in the "preys_on" column out into multiple rows, separated by comma or semicolon
  # need to still clean up: remove white space, etc (but tabling for now to go work on something else)
#  rename(resourceName = preys_on) # matches eventual edgelist

###### now with hosts for parasites #######

#consumers_psitehosts <- consumer_nodes %>% 
#  separate_rows(parasitic_on, sep = ",|;") %>%  # separate stuff in the "preys_on" column out into multiple rows, separated by comma or semicolon
  # need to still clean up: remove white space, etc (but tabling for now to go work on something else)
#  rename(resourceName = parasitic_on) # matches eventual edgelist

###### CLEANER alternative is to pivot_longer first and then separate_ ###### 

consumers_all_ints <- consumer_nodes %>% 
  pivot_longer(cols = c(parasitic_on, preys_on),
               names_to = "interaction_type",
               values_to = "resourceName") %>% 
  select(id.x, species, category, common_name, life_stage, n_s_both, zone, trophic_strategy, interaction_type, resourceName, source) %>% 
  separate_rows(resourceName, sep = ",|;") %>% 
  filter(!resourceName == "") %>% # i think we can safely remove any 'consumers' that don't have listed resources
  filter(!is.na(resourceName)) %>%  # i think we can safely remove any 'consumers' that don't have listed resources
  
  # now we need to clean up the names we're left with:
  mutate(resourceName = str_trim(resourceName)) %>% # remove extra whitespace both at beginning and end and middle
  mutate(resourceName = str_remove_all(resourceName, "\"")) #%>%  # lots of random quotes in this column, removed them
  #mutate(resourceName = str_remove(resourceName, "\\.$")) # this should remove periods only at the end of strings ($ does this) ## not actually including this because it messes with "sp."

  

################ next we can join with the species list and include relevant metadata, mainly the id number  ##################

##### make resource metadata for clean binding 
resource_nodes <- nodes_unclean %>% 
  select(id.x, species, alternate_nomenclature, zone, category, life_stage, n_s_both) %>% 
  rename(resourceNum = id.x, 
         resourceName = species, 
         resource_alt = alternate_nomenclature, 
         r_zone = zone, 
         resourceCat = category, 
         resourceStage = life_stage, 
         r_nsboth = n_s_both)

##### bind the two, only including consumers with matched resources

edges_from_node_metadata <- left_join(consumers_all_ints, resource_nodes, by = join_by(resourceName)) %>% 
  filter(!is.na(resourceNum)) # taking out the ones that didn't work

#write_csv(edges_from_node_metadata, "edges_from_metadata.csv") # just going to manually add these to edgelist master later

```
 Unfortunately we've ended up with WAY too many resources that didn't match nodes in our node list, so I'm going to proceed with the painful task of manual entry into the edgelist as of 3/20/2024
 
### we can make two csv's, one to paste into edgelist_MASTER and one to manually go through and enter by hand

```{r first of two csvs}

# start with the one that needs to be QCd since it's easier and doesn't need to match edgelist formatting:

edges_from_specieslist_manualentry <- left_join(consumers_all_ints, resource_nodes, by = join_by(resourceName)) %>% 
  filter(is.na(resourceNum)) # only including the ones that didn't match a species in the node list

#write_csv(edges_from_specieslist_manualentry, "data/edges_from_metadata_manualentry_21mar2024.csv")
```

```{r match edgelist_MASTER}
######### need to manipulate edges_from_specieslist so that it can be easily copied and pasted into edgelist_master ######### 
# eg remove higher taxonomy and make column names match
inxs_to_paste <- edges_from_node_metadata %>% 
  
  #add in columns that are present in edgelist master:
  mutate(date_added = "22 Mar 2024") %>% 
  mutate(INITIALS = "ZZ_coded") %>% 
  mutate(justification = 4) %>% 
  mutate(confidence = NA) %>% # keep this empty for now
  mutate(pools_exposed = NA) %>% # keep this empty for now
  mutate(incl.code = NA) %>% # keep this empty for now
  mutate(localities = NA) %>%  # keep this empty for now
  mutate(epibiota_consumed = NA) %>% 
  mutate(notes = NA) %>% 

  mutate(link.ID = (2350 + seq_len(length.out = n()))) %>%  # 2349 is currently the last link id # in edgelist_master so make sure to change
  rename(ref_num = source, 
         consumerName = species,
         consumerCat =category, 
         consumerNum = id.x
         #resourceName already matches,
         #resourceCat already matches
         ) %>% 
  mutate(MorrisHaderlie = case_when(str_detect(ref_num, "Morris") ~ "yes",
         .default = "no")) %>%
  
  # need to add a column that creates numeric life stage for consumers
  mutate(consumerStage = case_when(
    life_stage == "adult" | life_stage == "medusa" ~ 1,
    life_stage == "egg" ~ 2,
    life_stage == "larva" & consumerCat != "nematode" ~ 5, # first stage larva
    life_stage == "nauplii" ~ 3, # first stage larva
    life_stage == "procercoid" ~ 3, # first stage larva
    life_stage == "cystacanth" & resourceCat != "fish" ~ 3, # first stage larva eg cystacanth in arthropod, not fish
    life_stage == "plerocercoid" ~ 4, # 2nd stage larva
    life_stage == "juvenile" ~ 4, # juvenile fish/snail/crab
    life_stage == "cystacanth" & (resourceCat == "fish" | resourceCat == "bird" | resourceCat == "mammal") ~ 4, #2nd stage larva, might also need to add pinniped to this list
    life_stage == "hydroid" ~ 5, # polyp stage in cnidarians
    life_stage == "metacercaria" ~ 5,
    life_stage == "larva" & consumerCat == "nematode" ~ 5, #L3 larva in nematodes (pretty sure there are none in this list other than L3s in fish but double check)
    life_stage == "multiple" ~ 6, 
    .default = NA
  )) %>% 
  
  # need to add a column that creates numeric life stage for resources as well
  mutate(resourceStage = case_when(
    resourceStage == "adult" | resourceStage == "medusa" ~ 1,
    resourceStage == "egg" ~ 2,
    resourceStage == "juvenile" ~ 4, # juvenile fish/snail/crab
    resourceStage == "nauplii" ~ 3, # first stage larva
    resourceStage == "hydroid" | resourceStage == "hydroid colony" ~ 5, # polyp stage in cnidarians
    resourceStage == "multiple" ~ 6,
    .default = NA
  )) %>% 
  
  # need to add a column that creates interaction.type out of inxs$trophic_strategy + interaction_type (we only have two in this instance, parasitic_on and preys_on)
  mutate(trophic_strategy = replace_na(trophic_strategy, "not applicable")) %>% 
  mutate(interaction.type = case_when(
    interaction_type == "preys_on" & trophic_strategy == "typical predator" ~ 1, #normal predation
    interaction_type == "preys_on" & trophic_strategy == "carnivore (scavenger + predator)" ~ 1, #normal predation, but might have to QC whether true
    interaction_type == "preys_on" & trophic_strategy == "omnivore" ~ 1, #normal predation
    interaction_type == "preys_on" & trophic_strategy == "filter feeder" ~ 1, #normal predation
    
    interaction_type == "preys_on" & trophic_strategy == "scavenger" ~ 30, #scavenging
    interaction_type == "preys_on" & trophic_strategy == "detritivore" ~ 30, #scavenging
    
    
    trophic_strategy == "symbiotic egg predator" ~ 23, #symbiotic egg predation
    interaction_type == "preys_on" & trophic_strategy == "micropredator" ~ 3, #micropredation/grazing
     interaction_type == "preys_on" & trophic_strategy == "grazer" ~ 3, #micropredation/grazing
    
    interaction_type =="parasitic_on" ~ 6, #macroparasitism (endo)
    #interaction_type =="ectoparasitism" ~ 7, #ectoparasitism (true and ecto pathogen) 
    #interaction_type =="parasitic castration" ~ 4, 
    # non trophic:
    #interaction_type =="spatially associated" ~ 20, # habitat association 
    #interaction_type =="epiphytic" ~ 2, 
    #interaction_type =="epibiosis" ~ 2, 
    
    .default = NA # tried to make this a character but that didn't work so NA will have to do
  )) %>% 
  # now select out all the columns that don't match and put them in the right order
  select(INITIALS, consumerNum, consumerName, consumerCat, consumerStage, resourceNum, resourceName, resourceCat, resourceStage, interaction.type, confidence, justification, incl.code, ref_num, localities, zone, pools_exposed, MorrisHaderlie, epibiota_consumed, notes, link.ID, date_added)
                                                          

write_csv(inxs_to_paste, "data/specieslist_inxs_to_paste_22mar2024.csv")
```


### also decided pretty late in the game (june) to enter the interactions from the "eaten_by" column - in a new version of the species list i added a "clean_pred" column for this purpose
```{r pull in latest species list}

nodes_unclean2 <- read_csv("data/RIZspecieslist_fulltaxonomy_2jun24.csv")

```
```{r clean dataset for expanding resource relationships}
resource_nodes <- nodes_unclean2 %>% 
  select(!c(preys_on, non_trophic_epicommensal_w, mutualist_w, parasitized_by, unknown_symbiosis, how_picky_symbiotically, x41, clean_zone, googled, justification, confidence, node_type, node_resolution)) %>% 
  filter(!is.na(preds_clean))


################ now we need to expand the consumers (preds) for each resource  ##################

###### all we need to do is separate by comma because i prepped the dataframe ahead of time ###### 

resources_all_ints <- resource_nodes %>% 
  select(id.x, species, category, common_name, life_stage, n_s_both, zone, preds_clean, source) %>% 
  separate_rows(preds_clean, sep = ",") %>% 
  mutate(preds_clean = trimws(preds_clean)) %>% 
  rename(consumerName = preds_clean)
  
  
################ next we can join with the species list and include relevant metadata, mainly the id number  ##################

########### FIRST BY SPECIES ###########

##### make resource metadata for clean binding 
consumer_nodes <- nodes_unclean %>% 
  select(id.x, species, alternate_nomenclature, zone, category, genus, life_stage, n_s_both) %>% 
  rename(consumerNum = id.x, 
         consumerName = species, # needs to match consumerName in other dataframe so we can use that column to bind
         consumer_alt = alternate_nomenclature, 
         c_zone = zone, 
         consumerCat = category, 
         consumerGenus = genus,
         consumerStage = life_stage, 
         c_nsboth = n_s_both)

##### bind the two, only including consumers with matched resources

edges_from_node_metadata <- left_join(resources_all_ints, consumer_nodes, by = join_by(consumerName)) 

# split into two dataframes, the ones that matched and the ones that didnt
matched_species <- edges_from_node_metadata%>% 
  filter(!is.na(consumerNum)) %>%  # taking out the ones that didn't work
  mutate(matched_by = "species") %>% 
  select(!consumerGenus) # we wont need this and makes it hard to rbind

unmatched <- edges_from_node_metadata%>% 
  filter(is.na(consumerNum)) %>%  # keeping the ones that didn't work
  select(!c(consumerGenus, # we need this column to be gone for the next bind
         consumerNum, consumer_alt, consumerCat, consumerStage, c_zone, c_nsboth)) 

########### THEN BY GENUS ###########

# make resource dataframe for matching
genus_resource_nodes <- unmatched %>% 
  rename(consumerGenus = consumerName) # so we can bind using this column in consumer nodes

# bind
edges_from_genus <- left_join(genus_resource_nodes, consumer_nodes, by = join_by(consumerGenus)) 

# split into two dataframes, the ones that matched and the ones that didnt
matched_genus <- edges_from_genus%>% 
  filter(!is.na(consumerNum)) %>%  # taking out the ones that didn't work
  mutate(matched_by = "genus") %>% 
  select(!consumerGenus) # we wont need this after checking and makes it hard to rbind

unmatched_still <- edges_from_genus%>% 
  filter(is.na(consumerNum)) %>%  # keeping the ones that didn't work
  select(!c(consumerCat, # we need this column to be gone for the next bind
         consumerName, consumerNum, consumer_alt, consumerStage, c_zone, c_nsboth)) 
 

########### THEN BY CATEGORY ###########
# make resource dataframe for matching
cat_resource_nodes <- unmatched_still %>% 
  rename(consumerCat = consumerGenus) # so we can bind using this column in consumer nodes

# bind
edges_from_category <- left_join(cat_resource_nodes, consumer_nodes, by = join_by(consumerCat)) 

# split into two dataframes, the ones that matched and the ones that didnt
matched_cat <- edges_from_category%>% 
  filter(!is.na(consumerNum)) %>%  # taking out the ones that didn't work
  mutate(matched_by = "category") %>% 
  select(!consumerGenus) # we wont need this and makes it hard to rbind

unmatched4evr <- edges_from_category%>% 
  filter(is.na(consumerNum))  # keeping the ones that didn't work


```


### now to prepare to paste into edgelist again

```{r make csv to paste}  

# combine all successful matches
matched_all <- rbind(matched_species, matched_genus, matched_cat)%>% 
  mutate(justification = case_when(matched_by == "species" ~ 3,
                                   matched_by == "genus" ~ 6,
                                   matched_by == "category" ~ 6)) %>% 
  mutate(confidence = case_when(justification == 3 ~ 1,
                                justification == 6 ~ 2
                                ))

# remove higher taxonomy and make column names match
to_paste <- matched_all %>% 
  
  #add in columns that are present in edgelist master:
  mutate(date_added = "3 Jun 2024") %>% 
  mutate(INITIALS = "ZZ_coded") %>% 
  mutate(pools_exposed = NA) %>% # keep this empty for now
  mutate(incl.code = 1) %>% # keep this empty for now
  mutate(localities = "California") %>%  # keep this empty for now
  mutate(MorrisHaderlie = "y") %>%
  mutate(epibiota_consumed = "y") %>% 
  mutate(notes = NA) %>% 
  mutate(link.ID = (20491 + seq_len(length.out = n()))) %>%  # 19167 is currently the last link id # in edgelist_master so make sure to change
  rename(ref_num = source, 
         #consumerName matches
         #consumerCat already matches
         resourceNum = id.x,
         resourceStage = life_stage, # redundant with below but whatever
         resourceName = species,
         resourceCat = category,
         remove_zone = zone,
         zone = c_zone # i looked thorugh and i want to keep the consumer zone instead of resource zone
         ) %>% 
  
  # need to add a column that creates numeric life stage (i'm going to clean some of this manually bc its a disaster) for consumers
  mutate(consumerStage = case_when(
    consumerStage == "adult" | consumerStage == "medusa" ~ 1,
    consumerStage == "egg" ~ 2,
    #consumerStage == "larva" & consumerCat != "nematode" ~ 5, # first stage larva
    consumerStage == "nauplii" ~ 3, # first stage larva
    consumerStage == "procercoid" ~ 3, # first stage larva
    consumerStage == "redia" ~ 3, # first stage larva
    consumerStage == "cercaria" ~ 3, # first stage larva
    consumerStage == "sporocyst" ~ 3, # first stage larva
    #consumerStage == "cystacanth" & resource_phylum == "Arthropoda" ~ 3, # first stage larva eg cystacanth in arthropod
    consumerStage == "plerocercoid" ~ 4, # 2nd stage larva
    consumerStage == "juvenile" ~ 4, # juvenile fish/snail/crab
    #consumerStage == "cystacanth" & resource_phylum == "Chordata" ~ 4, #2nd stage larva
    consumerStage == "hydroid" ~ 5, # polyp stage in cnidarians
    consumerStage == "metacercaria" ~ 5,
    #consumerStage == "larva" & consumerCat == "nematode" ~ 5, #L3 larva in nematodes (pretty sure there are none in this list other than L3s in fish but double check)
    consumerStage == "multiple" ~ 6, 
    .default = NA
  )) %>% # i think that if this isn't perfect, that's ok because later in the pipeline i replace all this info with info from the node list
  
  # need to add a column that creates numeric life stage for resources as well
  mutate(resourceStage = case_when(
    resourceStage == "adult" | resourceStage == "medusa" ~ 1,
    resourceStage == "egg" ~ 2,
    resourceStage == "juvenile" ~ 4, # juvenile fish/snail/crab
    resourceStage == "nauplii" ~ 3, # first stage larva
    resourceStage == "hydroid" | resourceStage == "hydroid colony" ~ 5, # polyp stage in cnidarians
    resourceStage == "multiple" ~ 6,
    .default = NA
  )) %>% 
  
  mutate(interaction.type = 1)%>% # only predation here
  # now select out all the columns that don't match and put them in the right order
  select(INITIALS, consumerNum, consumerName, consumerCat, consumerStage, resourceNum, resourceName, resourceCat, resourceStage, interaction.type, confidence, justification, incl.code, ref_num, localities, zone, pools_exposed, MorrisHaderlie, epibiota_consumed, notes, link.ID, date_added)
                                                          

write_csv(to_paste, "data/specieslist_inxs_to_paste_3jun2024.csv")
```
