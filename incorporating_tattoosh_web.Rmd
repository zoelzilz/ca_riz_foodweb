---
title: "tattoosh web incorporation"
output: html_document
date: "2024-05-30"
---
```{r packages}

library(tidyverse)

```
# giving up, this web is full of lies (eg errors)

# Tatoosh Island Web from:
## Sander, E. L., Wootton, J. T., & Allesina, S. (2015). What Can Interaction Webs Tell Us About Species Roles? PLOS Computational Biology, 11(7), e1004330. https://doi.org/10.1371/journal.pcbi.1004330

## Network and taxonomic data for the Tatoosh network is available on Dryad at https://datadryad.org/stash/dataset/doi:10.5061/dryad.39jv1

### before this (a long time ago) I converted the matrix in that repository into an edgelist csv (r project: RIZ, Tatoosh.Rmd)

```{r import tatoosh data and my data}

## my node list
ca_nodes <- read_csv("data/RIZspecieslist_fulltaxonomy_28may24.csv") %>% 
  rename(Name = species) # name is just easier

# tatoosh node list 

tat_nodes <- read_csv("data/tatoosh_web/Tatoosh-Taxonomy.csv") %>% 
  rename(Name = input) %>% # also so it matches
  select(!3:17) # these columns are useless to us

# tatoosh iz web
tat_web <- read_csv("data/tatoosh_web/Tatoosh_EdgeList.csv")

```

## Step 1: Wrangle Tattoosh nodes so they match my nodes
```{r node wrangling}

# first start by keeping species in my list that are present in tatoosh list
matched_species <- inner_join(tat_nodes, ca_nodes, by = join_by(Name)) %>% 
  mutate(matched_using = "species")

# i also want to see which species didn't get matched to make sure i should actually leave them out, because this dataset is funky
unmatched <- anti_join(tat_nodes, ca_nodes, by = join_by(Name))

# now we will make a list of genera in the tatoosh list that are in my list 
tat_genera <- tat_nodes %>% 
  rename(genus = Name) # so we can join on genus column in ca_nodes (e.g. see where the name in the tatoosh list matches a genus in our list)

matched_genera <- inner_join(tat_genera, ca_nodes, by = join_by(genus))%>% 
  mutate(matched_using = "genus") # resulted in like 40 ish species being matched

tat_fams <- tat_nodes %>% 
  rename(family = Name) # so we can join on family column in ca_nodes (e.g. see where the name in the tatoosh list matches a family in our list)

matched_families <- inner_join(tat_fams, ca_nodes, by = join_by(family))%>% 
  mutate(matched_using = "family")

# need to make a full list of all the matched taxa and include a column indicating how that taxon was matched (e.g. species, genus, family)

matched_nodes_all <- rbind(matched_species, matched_genera, matched_families) # about 146 nodes!

```

## Step 2: Wrangling the tatoosh links to match my node info

#### 146 nodes in the california web are represented in the tatoosh web, either by their exact species (n = 56), their genus (n = 47), or their family (n = 43 spp from 2 families). This leaves out nodes that might be the same but be called a different or old name. Oh well!

```{r link wrangling for all matched taxa}
# make a version of the matched nodes list to join with the link list (need to make sure IDs can bind)

# first for consumers
consumers_to_match <- matched_nodes_all %>% 
  rename(Consumer = original_name)  # ID column name in link list is Consumer, need to match using the original names from the dataset (because i manually changed some names to match my names)

consumers_data <- inner_join(tat_web, consumers_to_match, by = join_by(Consumer), relationship = "many-to-many") %>% 
  select(Consumer, Name, id.x, common_name, category, life_stage, Resource, matched_using) # only need some relevant data, can add more later

# then for resources
resources_to_match <- matched_nodes_all %>% 
  rename(Resource = original_name) %>%   # ID column name in link list is Resource, need to match using the original names from the dataset (because i manually changed some names to match my names)
  select(Resource, Name, id.x, common_name, category, life_stage, matched_using, zone)

# now put all links together
consumer_resource_links <- inner_join( # did left_join at first but it included a lot of resources that didn't match ca nodes
  consumers_data, resources_to_match, by = join_by(Resource), relationship = "many-to-many") # this matching should also automatically add .x to columns from consumers_data and .y to resources_to_match

```

## Step 3: Create links to add to main edge list
### MASTER CODE for manipulating dataframes to match with edgelist_master
```{r match edgelist_MASTER}

sanak_links_to_paste <- consumer_resource_links %>% 
  #filter(!is.na(resourceNum)) %>% ## we already did this by using inner join above
  
  #add in columns that are present in edgelist master:
  mutate(date_added = "29 May 2024") %>% 
  mutate(INITIALS = "ZZ_coded") %>% 
  
  # need to change the below so they are different based on what taxon they were matched using (species, genus, or family)
  mutate(justification = case_when(matched_using.x == "species" & matched_using.y == "species" ~ 3, # read in a paper
                                   .default = 6) # read in lit at higher taxonomic level
                                   ) %>% 
  mutate(incl.code = 2) %>% # both species in web but interaction reported elsewhere
  mutate(confidence = case_when(justification == 3 ~ 2,
                                justification == 6 ~ 3) # 2 both higher taxa in web but interaction reported elsewhere
           ) %>% 
  mutate(pools_exposed = NA) %>% # keep this empty for now
  mutate(localities = "Sanak Archipelago") %>%  
  mutate(MorrisHaderlie = "no") %>%
  mutate(epibiota_consumed = "y") %>% 
  mutate(notes = "") %>% 
  mutate(link.ID = (11849 + seq_len(length.out = n()))) %>%  # 11849 is currently the last link id # in edgelist_master so make sure to change
  mutate(ref_num = "375, 376") %>% # ref nums for both sanak web papers
  mutate(interaction.type = case_when(
    str_detect(category.y, "algae") ~ 3, 
    .default = 1)
  ) %>%  
  rename(consumerNum = ca_id.x, 
         consumerName = Name.x,
         consumerCat = category.x,
         resourceNum = ca_id.y,
         resourceName = Name.y,
         resourceCat = category.y
         ) %>% 
    
   # need to add a column that creates numeric life stage for consumers
  mutate(consumerStage = case_when(
    life_stage.x == "adult" | life_stage.x == "medusa" ~ 1,
    life_stage.x == "egg" ~ 2,
    life_stage.x == "juvenile" ~ 4, # juvenile fish/snail/crab
    life_stage.x == "hydroid" ~ 5, # polyp stage in cnidarians
    life_stage.x == "multiple" ~ 6, 
    .default = NA
  )) %>% 
  
  # need to add a column that creates numeric life stage for resources as well
  mutate(resourceStage = case_when(
    life_stage.y == "adult" | life_stage.y == "medusa" ~ 1,
    life_stage.y == "egg" ~ 2,
    life_stage.y == "juvenile" ~ 4, # juvenile fish/snail/crab
    life_stage.y == "small" ~ 4, # juvenile other
    life_stage.y == "nauplii" ~ 3, # first stage larva
    life_stage.y == "hydroid" | life_stage.y == "hydroid colony" ~ 5, # polyp stage in cnidarians
    life_stage.y == "multiple" ~ 6,
    .default = NA
  )) %>% 

  # now select out all the columns that don't match and put them in the right order
  select(INITIALS, consumerNum, consumerName, consumerCat, consumerStage, resourceNum, resourceName, resourceCat, resourceStage, interaction.type, confidence, justification, incl.code, ref_num, localities, zone, pools_exposed, MorrisHaderlie, epibiota_consumed, notes, link.ID, date_added)
                                                          

```

## Step 4: export to CSV
```{r create csv to merge with edgelist master}

write_csv(sanak_links_to_paste, "data/sanak_links_to_paste_29may2024.csv")

```